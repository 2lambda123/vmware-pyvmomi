from typing import List
from enum import Enum
from pyVmomi import vim, vmodl
from pyVmomi.VmomiSupport import double, long


class ApplyRecommendationResult(vmodl.DynamicData):
    @property
    def vm(self) -> vim.VirtualMachine: ...


class AutomationConfig(vmodl.DynamicData):
    @property
    def spaceLoadBalanceAutomationMode(self) -> str: ...
    @property
    def ioLoadBalanceAutomationMode(self) -> str: ...
    @property
    def ruleEnforcementAutomationMode(self) -> str: ...
    @property
    def policyEnforcementAutomationMode(self) -> str: ...
    @property
    def vmEvacuationAutomationMode(self) -> str: ...


class ConfigInfo(vmodl.DynamicData):
    @property
    def podConfig(self) -> PodConfigInfo: ...
    @property
    def vmConfig(self) -> List[VmConfigInfo]: ...


class ConfigSpec(vmodl.DynamicData):
    @property
    def podConfigSpec(self) -> PodConfigSpec: ...
    @property
    def vmConfigSpec(self) -> List[VmConfigSpec]: ...


class HbrDiskMigrationAction(vim.cluster.Action):
    @property
    def collectionId(self) -> str: ...
    @property
    def collectionName(self) -> str: ...
    @property
    def diskIds(self) -> List[str]: ...
    @property
    def source(self) -> vim.Datastore: ...
    @property
    def destination(self) -> vim.Datastore: ...
    @property
    def sizeTransferred(self) -> long: ...
    @property
    def spaceUtilSrcBefore(self) -> float: ...
    @property
    def spaceUtilDstBefore(self) -> float: ...
    @property
    def spaceUtilSrcAfter(self) -> float: ...
    @property
    def spaceUtilDstAfter(self) -> float: ...
    @property
    def ioLatencySrcBefore(self) -> float: ...
    @property
    def ioLatencyDstBefore(self) -> float: ...


class IoLoadBalanceConfig(vmodl.DynamicData):
    @property
    def reservablePercentThreshold(self) -> int: ...
    @property
    def reservableIopsThreshold(self) -> int: ...
    @property
    def reservableThresholdMode(self) -> str: ...
    @property
    def ioLatencyThreshold(self) -> int: ...
    @property
    def ioLoadImbalanceThreshold(self) -> int: ...


class OptionSpec(vim.option.ArrayUpdateSpec):
    @property
    def option(self) -> vim.option.OptionValue: ...


class PlacementAffinityRule(vmodl.DynamicData):
    @property
    def ruleType(self) -> str: ...
    @property
    def ruleScope(self) -> str: ...
    @property
    def vms(self) -> List[vim.VirtualMachine]: ...
    @property
    def keys(self) -> List[str]: ...


    class RuleScope(Enum):
        cluster = "cluster"
        host = "host"
        storagePod = "storagePod"
        datastore = "datastore"


    class RuleType(Enum):
        affinity = "affinity"
        antiAffinity = "antiAffinity"
        softAffinity = "softAffinity"
        softAntiAffinity = "softAntiAffinity"


class PlacementRankResult(vmodl.DynamicData):
    @property
    def key(self) -> str: ...
    @property
    def candidate(self) -> vim.ClusterComputeResource: ...
    @property
    def reservedSpaceMB(self) -> long: ...
    @property
    def usedSpaceMB(self) -> long: ...
    @property
    def totalSpaceMB(self) -> long: ...
    @property
    def utilization(self) -> double: ...
    @property
    def faults(self) -> List[vmodl.MethodFault]: ...


class PlacementRankSpec(vmodl.DynamicData):
    @property
    def specs(self) -> List[vim.cluster.PlacementSpec]: ...
    @property
    def clusters(self) -> List[vim.ClusterComputeResource]: ...
    @property
    def rules(self) -> List[PlacementAffinityRule]: ...
    @property
    def placementRankByVm(self) -> List[PlacementRankVmSpec]: ...


class PlacementRankVmSpec(vmodl.DynamicData):
    @property
    def vmPlacementSpec(self) -> vim.cluster.PlacementSpec: ...
    @property
    def vmClusters(self) -> List[vim.ClusterComputeResource]: ...


class PodConfigInfo(vmodl.DynamicData):
    @property
    def enabled(self) -> bool: ...
    @property
    def ioLoadBalanceEnabled(self) -> bool: ...
    @property
    def defaultVmBehavior(self) -> str: ...
    @property
    def loadBalanceInterval(self) -> int: ...
    @property
    def defaultIntraVmAffinity(self) -> bool: ...
    @property
    def spaceLoadBalanceConfig(self) -> SpaceLoadBalanceConfig: ...
    @property
    def ioLoadBalanceConfig(self) -> IoLoadBalanceConfig: ...
    @property
    def automationOverrides(self) -> AutomationConfig: ...
    @property
    def rule(self) -> List[vim.cluster.RuleInfo]: ...
    @property
    def option(self) -> List[vim.option.OptionValue]: ...


    class Behavior(Enum):
        manual = "manual"
        automated = "automated"


class PodConfigSpec(vmodl.DynamicData):
    @property
    def enabled(self) -> bool: ...
    @property
    def ioLoadBalanceEnabled(self) -> bool: ...
    @property
    def defaultVmBehavior(self) -> str: ...
    @property
    def loadBalanceInterval(self) -> int: ...
    @property
    def defaultIntraVmAffinity(self) -> bool: ...
    @property
    def spaceLoadBalanceConfig(self) -> SpaceLoadBalanceConfig: ...
    @property
    def ioLoadBalanceConfig(self) -> IoLoadBalanceConfig: ...
    @property
    def automationOverrides(self) -> AutomationConfig: ...
    @property
    def rule(self) -> List[vim.cluster.RuleSpec]: ...
    @property
    def option(self) -> List[OptionSpec]: ...


class PodSelectionSpec(vmodl.DynamicData):
    @property
    def initialVmConfig(self) -> List[PodSelectionSpec.VmPodConfig]: ...
    @property
    def storagePod(self) -> vim.StoragePod: ...


    class DiskLocator(vmodl.DynamicData):
        @property
        def diskId(self) -> int: ...
        @property
        def diskMoveType(self) -> str: ...
        @property
        def diskBackingInfo(self) -> vim.vm.device.VirtualDevice.BackingInfo: ...
        @property
        def profile(self) -> List[vim.vm.ProfileSpec]: ...


    class VmPodConfig(vmodl.DynamicData):
        @property
        def storagePod(self) -> vim.StoragePod: ...
        @property
        def disk(self) -> List[PodSelectionSpec.DiskLocator]: ...
        @property
        def vmConfig(self) -> VmConfigInfo: ...
        @property
        def interVmRule(self) -> List[vim.cluster.RuleInfo]: ...


class SpaceLoadBalanceConfig(vmodl.DynamicData):
    @property
    def spaceThresholdMode(self) -> str: ...
    @property
    def spaceUtilizationThreshold(self) -> int: ...
    @property
    def freeSpaceThresholdGB(self) -> int: ...
    @property
    def minSpaceUtilizationDifference(self) -> int: ...


    class SpaceThresholdMode(Enum):
        utilization = "utilization"
        freeSpace = "freeSpace"


class StorageMigrationAction(vim.cluster.Action):
    @property
    def vm(self) -> vim.VirtualMachine: ...
    @property
    def relocateSpec(self) -> vim.vm.RelocateSpec: ...
    @property
    def source(self) -> vim.Datastore: ...
    @property
    def destination(self) -> vim.Datastore: ...
    @property
    def sizeTransferred(self) -> long: ...
    @property
    def spaceUtilSrcBefore(self) -> float: ...
    @property
    def spaceUtilDstBefore(self) -> float: ...
    @property
    def spaceUtilSrcAfter(self) -> float: ...
    @property
    def spaceUtilDstAfter(self) -> float: ...
    @property
    def ioLatencySrcBefore(self) -> float: ...
    @property
    def ioLatencyDstBefore(self) -> float: ...


class StoragePlacementAction(vim.cluster.Action):
    @property
    def vm(self) -> vim.VirtualMachine: ...
    @property
    def relocateSpec(self) -> vim.vm.RelocateSpec: ...
    @property
    def destination(self) -> vim.Datastore: ...
    @property
    def spaceUtilBefore(self) -> float: ...
    @property
    def spaceDemandBefore(self) -> float: ...
    @property
    def spaceUtilAfter(self) -> float: ...
    @property
    def spaceDemandAfter(self) -> float: ...
    @property
    def ioLatencyBefore(self) -> float: ...


class StoragePlacementResult(vmodl.DynamicData):
    @property
    def recommendations(self) -> List[vim.cluster.Recommendation]: ...
    @property
    def drsFault(self) -> vim.cluster.DrsFaults: ...
    @property
    def task(self) -> vim.Task: ...


class StoragePlacementSpec(vmodl.DynamicData):
    @property
    def type(self) -> str: ...
    @property
    def priority(self) -> vim.VirtualMachine.MovePriority: ...
    @property
    def vm(self) -> vim.VirtualMachine: ...
    @property
    def podSelectionSpec(self) -> PodSelectionSpec: ...
    @property
    def cloneSpec(self) -> vim.vm.CloneSpec: ...
    @property
    def cloneName(self) -> str: ...
    @property
    def configSpec(self) -> vim.vm.ConfigSpec: ...
    @property
    def relocateSpec(self) -> vim.vm.RelocateSpec: ...
    @property
    def resourcePool(self) -> vim.ResourcePool: ...
    @property
    def host(self) -> vim.HostSystem: ...
    @property
    def folder(self) -> vim.Folder: ...
    @property
    def disallowPrerequisiteMoves(self) -> bool: ...
    @property
    def resourceLeaseDurationSec(self) -> int: ...


    class PlacementType(Enum):
        create = "create"
        reconfigure = "reconfigure"
        relocate = "relocate"
        clone = "clone"


class VirtualDiskAntiAffinityRuleSpec(vim.cluster.RuleInfo):
    @property
    def diskId(self) -> List[int]: ...


class VirtualDiskRuleSpec(vim.cluster.RuleInfo):
    @property
    def diskRuleType(self) -> str: ...
    @property
    def diskId(self) -> List[int]: ...


class VmConfigInfo(vmodl.DynamicData):
    @property
    def vm(self) -> vim.VirtualMachine: ...
    @property
    def enabled(self) -> bool: ...
    @property
    def behavior(self) -> str: ...
    @property
    def intraVmAffinity(self) -> bool: ...
    @property
    def intraVmAntiAffinity(self) -> VirtualDiskAntiAffinityRuleSpec: ...
    @property
    def virtualDiskRules(self) -> List[VirtualDiskRuleSpec]: ...


class VmConfigSpec(vim.option.ArrayUpdateSpec):
    @property
    def info(self) -> VmConfigInfo: ...